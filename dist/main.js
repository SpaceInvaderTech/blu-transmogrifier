import{createECDH as Q,createHash as T,createSign as V} from"node:crypto";import{Buffer as z} from"node:buffer";import{Buffer as N} from"node:buffer";var O=Object.freeze({manifest:{application:{bin_file:"firmware.bin",dat_file:"initpacket.dat"}}}),M=Object.freeze({header:N.from([18,138,1,10,68,8,1,18,64]),body:N.from([8,1,16,52,26,2,131,2,32,0,40,0,48,0,56,156,141,3,66,36,8,3,18,32]),fixedData:N.from([72,0,82,4,8,1,18,0,16,0,26,64])});var W=function(){const L=Q("secp224r1");return L.generateKeys(),L.getPrivateKey()},X=function(L,U,q){const j=z.from(U,"binary");if(j.byteLength!==q.byteLength)throw new Error("Public key is not the same length as the pattern");const G=L.indexOf(j);if(G===-1)throw new Error("Pattern not found in firmware");const J=z.from(L);return q.copy(J,G),J},Y=function(L){const U=Q("secp224r1");U.setPrivateKey(L);const q=U.getPublicKey(null,"compressed");return z.from(q.subarray(1))},Z=function(L){const U=T("sha256").update(L).digest();return z.from(U.reverse())},_=function(L,U){const j=V("SHA256").update(L).end().sign({key:U,dsaEncoding:"ieee-p1363"}),G=z.from(j.subarray(0,32)),J=z.from(j.subarray(32,64));return z.concat([G.reverse(),J.reverse()])},$=function(L,U){const q=Z(L),j=z.concat([M.body,q,M.fixedData]),G=_(j,U);return z.concat([M.header,j,G])};function x({firmware:L,pattern:U,privateKey:q,privateKeyForAccessory:j=W()}){const G=Y(j),J=X(L,U,G),R=$(J,q);return{manifest:O,initPacket:R,firmwarePatched:J}}export{x as default};
