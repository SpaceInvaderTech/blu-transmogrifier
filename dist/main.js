import{createECDH as Q,createHash as T,createSign as V} from"node:crypto";import{Buffer as G} from"node:buffer";import{Buffer as N} from"node:buffer";var O=Object.freeze({manifest:{application:{bin_file:"firmware.bin",dat_file:"initpacket.dat"}}}),M=Object.freeze({header:N.from([18,138,1,10,68,8,1,18,64]),body:N.from([8,1,16,52,26,2,131,2,32,0,40,0,48,0,56,156,141,3,66,36,8,3,18,32]),fixedData:N.from([72,0,82,4,8,1,18,0,16,0,26,64])});var W=function(){const U=Q("secp224r1");return U.generateKeys(),U.getPrivateKey()},X=function(U,j,z){const q=G.from(j,"binary");if(q.byteLength!==z.byteLength)throw new Error("Public key is not the same length as the pattern");const J=U.indexOf(q);if(J===-1)throw new Error("Pattern not found in firmware");const L=G.from(U);return z.copy(L,J),L},Y=function(U){const j=Q("secp224r1");j.setPrivateKey(U);const z=j.getPublicKey(null,"compressed");return G.from(z.subarray(1))},Z=function(U){const j=T("sha256").update(U).digest();return G.from(j.reverse())},_=function(U,j){const q=V("SHA256").update(U).end().sign({key:j,dsaEncoding:"ieee-p1363"}),J=G.from(q.subarray(0,32)),L=G.from(q.subarray(32,64));return G.concat([J.reverse(),L.reverse()])},$=function(U,j){const z=Z(U),q=G.concat([M.body,z,M.fixedData]),J=_(q,j);return G.concat([M.header,q,J])};function C({firmware:U,pattern:j,privateKey:z,privateKeyForAccessory:q=W()}){const J=Y(q),L=X(U,j,J),R=$(L,z);return{manifest:O,initPacket:R,firmwarePatched:L}}export{C as default};
